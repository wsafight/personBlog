# 手写一个业务数据比对库

处理表单更新对于业务开发来说必不可少。而在前端数据对服务端提交时候，往往需要一个数据比对来剔除不需要更新的数据项。于是个人写了一个业务数据比对库
[diff-helper](https://github.com/wsafight/diff-helper.git)。

## 项目演进

任何项目都不是一触而就的，下面是关于 diff-helper 库的编写思路。希望能对大家有一些帮助。

### 简单对象比对

进行数据更新时候，很多情况下都是对象一层数据比对。在不考虑对象中还有对象或者数组的情况下，代码如下所示。

```ts
const simpleObjDiff = ({
  newVal,
  oldVal,
}): Record<string, any> => {
  // 当前比对的结果
  const diffResult: Record<string, any> = {};

  // 已经检查过的数据项
  const checkedKeys: Set<string> = new Set();

  // 遍历最新的对象数据
  Object.keys(newVal).forEach((key: string) => {
    // 当前已经处理过的对象 key 记录一下
    checkedKeys.add(key);

    // 如果当前新的数据不等于老数据，直接把新的比对结果放入
    if (newVal[key] !== oldVal[key]) {
      diffResult[key] = newVal[key];
    }
  });

  // 遍历之前的对象书就
  Object.keys(oldVal).forEach((key) => {
    // 如果已经检查过了，直接返回
    if (checkedKeys.has(key)) {
      return;
    }
    // 否则认为数据为 null，设置比对数据
    diffResult[key] = null;
  });
  return diffResult;
};
```

此时我们就可以使用该函数进行一系列简单数据操作了。

```ts
const result = simpleObjDiff({
  newVal: {
    a: 1,
    b: 1,
  },
  oldVal: {
    a: 2,
    c: 2,
  },
});
// => 返回结果为
result = {
  a: 1,
  b: 1,
  c: null,
};
```

#### 添加复杂属性比对

当前代码可以适用于绝大部份场景了，但却没有办法处理复杂类型。考虑到提交到服务端的表单数据一般不需要增量提交，所以我们这里采用 JSON.stringify。

诸如:

```ts
JSON.stringify("123");
// '"123"'

JSON.stringify(123);
// '123'

JSON.stringify(new Date());
// '"2022-11-29T15:16:46.325Z"'

JSON.stringify([1, 2, 3]);
// '[1,2,3]'

JSON.stringify({ a: 1, b: 2 });
// '{"b":2,"a":1}'

JSON.stringify({ b: 2, a: 1 });
// '{"b":2,"a":1}'

JSON.stringify({ b: 2, a: 1 }, ["a", "b"]);
// '{"a":1,"b":2}'
```

对比上述结果，可以看到针对对象类型，JSON.stringify 如果不提供 replacer
数组可能会对生成结果产生“误伤”。但从系统实际运行上来说，对象内部很难出现排序异常的情况。所以我们就做如下改造处理。

```ts
const simpleObjDiff = ({
  newVal,
  oldVal,
}): Record<string, any> => {
  // ... 之前的代码

  // 遍历最新的对象数据
  Object.keys(newVal).forEach((key: string) => {
    // 当前已经处理过的对象 key 记录一下
    checkedKeys.add(key);

    // 先去查看类型，判断相同类型后再使用 JSON.stringify 获取字符串结果进行比对
    if (
      typeof newVal[key] !== typeof oldVal[key] ||
      JSON.stringify(newVal[key]) !== JSON.stringify(oldVal[key])
    ) {
      diffResult[key] = newVal[key];
    }
  });
  // ...
};
```

这时候 simpleObjDiff 函数又变得更加强大，如下所示：

```ts
const result = simpleObjDiff({
  newVal: {
    a: 1,
    b: 1,
    d: [1, 2, 3],
  },
  oldVal: {
    a: 2,
    c: 2,
    d: [1, 2, 3],
  },
});
// => 返回结果为
result = {
  a: 1,
  b: 1,
  c: null,
};
```

#### 添加自定义对象属性比对

如果只使用 JSON.stringify 话，函数就没有办法灵活的处理用户的各色需求，所以开始添加自定义 diff 函数。

```ts
const simpleObjDiff = ({
  newVal,
  oldVal,
  options,
}): Record<string, any> => {
  // ... 之前的代码

  // 获取用户定义的 diff 函数
  const { diffFun } = { ...DEFAULT_OPTIONS, ...options };

  // 判断当前传入数据是否是函数
  const hasDiffFun = typeof diffFun === "function";

  // 遍历最新的对象数据
  Object.keys(newVal).forEach((key: string) => {
    // 当前已经处理过的对象 key 记录一下
    checkedKeys.add(key);

    let isChanged = false;

    if (hasDiffFun) {
      // 把当前属性 key 和对应的值传入，就可以获取结果
      const diffResultByKey = diffFun({
        key,
        newPropVal: newVal[key],
        oldPropVal: oldVal[key],
      });

      // 返回了结果则写入 diffResult，没有结果认为传入的函数不处理
      if (
        diffResultByKey !== null &&
        diffResultByKey !== undefined
      ) {
        diffResult[key] = diffResultByKey;
        isChanged = true;
      }
    }

    if (isChanged) {
      return;
    }

    if (
      typeof newVal[key] !== typeof oldVal[key] ||
      JSON.stringify(newVal[key]) !== JSON.stringify(oldVal[key])
    ) {
      diffResult[key] = needCopy
        ? JSON.parse(JSON.stringify(newVal))
        : newVal[key];
    }
  });
  // ...
};
```

此时我们尝试传入 diffFun 来看看效果：

```ts
const result = simpleObjDiff({
  newVal: {
    a: [12, 3, 4],
    b: 11,
  },
  oldVal: {
    a: [1, 2, 3],
    c: 22,
  },
  options: {
    diffFun: ({
      key,
      newPropVal,
      oldPropVal,
    }) => {
      switch (key) {
        // 处理对象中的属性 a
        case "a":
          return newPropVal.filter((item: any) => oldPropVal.includes(item));
      }
      // 其他我们选择不处理，使用默认的 JSON.stringify
      return null;
    },
  },
});
// =>
result = {
  // 结果如下所示
  a: [3],
  b: 11,
  c: null,
};
```

通过 diffFun 函数，开发者不但可以自定义属性处理，还可以利用
[fast-json-stringify](https://github.com/fastify/fast-json-stringify)
来优化内部属性处理。通过 JSON schema 预先告知对象属性类型，fast-json-stringify 性能非常高。

```ts
import fastJson from "fast-json-stringify";

const stringify = fastJson({
  title: "User Schema",
  type: "object",
  properties: {
    firstName: {
      type: "string",
    },
    lastName: {
      type: "string",
    },
    age: {
      description: "Age in years",
      type: "integer",
    },
  },
});

console.log(stringify({
  firstName: "Matteo",
  lastName: "Collina",
  age: 32,
}));
// "{\"firstName\":\"Matteo\",\"lastName\":\"Collina\",\"age\":32}"

console.log(stringify({
  lastName: "Collina",
  age: 32,
  firstName: "Matteo",
}));
// "{\"firstName\":\"Matteo\",\"lastName\":\"Collina\",\"age\":32}"
```

可以看到，利用 fast-json-stringify 无需考虑对象属性的内部顺序。

#### 添加其他处理

```ts
// 添加异常错误抛出
const invariant = (condition: boolean, errorMsg: string) => {
  if (condition) {
    throw new Error(errorMsg);
  }
};

// 判断是否是真实的对象
const isRealObject = (val: any): val is Record<string, any> => {
  return Object.prototype.toString.call(val) === "[object Object]";
};

simpleObjDiff = ({
  newVal,
  oldVal,
  options,
}: SimpleObjDiffParams): Record<string, any> => {
  // 添加错误传参处理
  invariant(!isRealObject(newVal), "params newVal must be a Object");
  invariant(!isRealObject(oldVal), "params oldVal must be a Object");

  // ...
  const { diffFun, empty } = { ...DEFAULT_OPTIONS, ...options };

  // ...

  Object.keys(oldVal).forEach((key) => {
    // 如果已经检查过了，直接返回
    if (checkedKeys.has(key)) {
      return;
    }
    // 设定空数据，建议使用 null 或 空字符串
    diffResult[key] = empty;
  });
};
```

如此一来，我们提交给后端的简单对象比对函数就完成了。

### 简单数组对比

## 参考资料

[fast-json-stringify](https://github.com/fastify/fast-json-stringify)
