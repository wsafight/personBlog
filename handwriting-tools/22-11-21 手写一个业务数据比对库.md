# 手写一个业务数据比对库

处理表单更新对于业务开发来说必不可少。而在前端数据对服务端提交时候，往往需要一个数据比对来剔除不需要更新的数据项。于是个人写了一个业务数据比对库
[diff-helper](https://github.com/wsafight/diff-helper.git)。

## 项目演进

任何项目都不是一触而就的，下面是关于 diff-helper 库的编写思路。希望能对大家有一些帮助。

### 简单对象比对

进行数据更新时候，很多情况下都是对象一层数据比对。在不考虑对象中还有对象或者数组的情况下，代码如下所示。

```ts
const simpleObjDiff = ({
  newVal,
  oldVal,
}): Record<string, any> => {
  // 当前比对的结果
  const diffResult: Record<string, any> = {};

  // 已经检查过的数据项
  const checkedKeys: Set<string> = new Set();

  // 遍历最新的对象数据
  Object.keys(newVal).forEach((key: string) => {
    // 当前已经处理过的对象 key 记录一下
    checkedKeys.add(key);

    // 如果当前新的数据不等于老数据，直接把新的比对结果放入
    if (newVal[key] !== oldVal[key]) {
      diffResult[key] = newVal[key];
    }
  });

  // 遍历之前的对象书就
  Object.keys(oldVal).forEach((key) => {
    // 如果已经检查过了，直接返回
    if (checkedKeys.has(key)) {
      return;
    }
    // 否则认为数据为 null，设置比对数据
    diffResult[key] = null;
  });
  return diffResult;

};
```

此时我们就可以使用该函数进行一系列简单数据操作了。

```ts
simpleObjDiff({})
// =>
```

#### 添加复杂属性比对

当前代码已经基本可用，下一步开始考虑数据项的检测了。大部分情况下，服务端不会针对一个

```

```
#### 添加自定义对象属性比对

大部分情况下，JSON.stringify 已经可以满足我们的需要的，这里提供一个函数来让用户可以自定义函数来处理。

此时我们还可以利用 fastJson 来优化内部属性遍历。



#### 添加错误处理
```ts
const invariant = (condition: boolean, errorMsg: string) => {
  if (condition) {
    throw new Error(errorMsg);
  }
}

// 判断是否是真实的对象
const isRealObject = (val: any): val is Record<string, any> => {
  return Object.prototype.toString.call(val) === '[object Object]'
}

simpleObjDiff = ({
  newVal,
  oldVal,
  options,
}: SimpleObjDiffParams): Record<string, any> => {
  // 添加错误传参处理
  invariant(!isRealObject(newVal), "params newVal must be a Object");
  invariant(!isRealObject(oldVal), "params oldVal must be a Object");

  // ...
}
```


### 简单数组对比



## 参考资料

[fast-json-stringify](https://github.com/fastify/fast-json-stringify)
