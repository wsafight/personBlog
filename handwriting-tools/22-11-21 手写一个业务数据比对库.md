# 手写一个业务数据比对库

处理表单更新对于业务开发来说必不可少。而在前端数据对服务端提交时候，往往需要一个数据比对来剔除不需要更新的数据项。于是个人写了一个业务数据比对库
[diff-helper](https://github.com/wsafight/diff-helper.git)。

## 项目演进

任何项目都不是一触而就的，下面是关于 diff-helper 库的编写思路。希望能对大家有一些帮助。

### 简单对象比对

进行数据更新时候，很多情况下都是对象一层数据比对。在不考虑对象中还有对象或者数组的情况下，代码如下所示。

```ts
const simpleObjDiff = ({
  newVal,
  oldVal,
}): Record<string, any> => {
  // 当前比对的结果
  const diffResult: Record<string, any> = {};

  // 已经检查过的数据项
  const checkedKeys: Set<string> = new Set();

  // 遍历最新的对象数据
  Object.keys(newVal).forEach((key: string) => {
    // 当前已经处理过的对象 key 记录一下
    checkedKeys.add(key);

    // 如果当前新的数据不等于老数据，直接把新的比对结果放入
    if (newVal[key] !== oldVal[key]) {
      diffResult[key] = newVal[key];
    }
  });

  // 遍历之前的对象书就
  Object.keys(oldVal).forEach((key) => {
    // 如果已经检查过了，直接返回
    if (checkedKeys.has(key)) {
      return;
    }
    // 否则认为数据为 null，方便服务端清空数据
    diffResult[key] = null;
  });
  return diffResult;
};
```

此时我们就可以使用该函数进行一系列简单数据操作了。

```ts
const result = simpleObjDiff({
  newVal: {
    a: 1,
    b: 1,
  },
  oldVal: {
    a: 2,
    c: 2,
  },
});
// => 返回结果为
result = {
  a: 1,
  b: 1,
  c: null,
};
```

#### 添加复杂属性比对

当前代码可以适用于绝大部份场景了，但却没有办法处理复杂类型。考虑到提交到服务端的表单数据一般不需要增量提交，所以我们这里采用 JSON.stringify。

诸如:

```ts
JSON.stringify("123");
// '"123"'

JSON.stringify(123);
// '123'

JSON.stringify(new Date());
// '"2022-11-29T15:16:46.325Z"'

JSON.stringify([1, 2, 3]);
// '[1,2,3]'

JSON.stringify({ a: 1, b: 2 });
// '{"b":2,"a":1}'

JSON.stringify({ b: 2, a: 1 });
// '{"b":2,"a":1}'

JSON.stringify({ b: 2, a: 1 }, ["a", "b"]);
// '{"a":1,"b":2}'
```

对比上述结果，可以看到针对对象类型，JSON.stringify 如果不提供 replacer
数组可能会对生成结果产生“误伤”。但从系统实际运行上来说，对象内部很难出现排序异常的情况。所以我们就做如下改造处理。

```ts
const simpleObjDiff = ({
  newVal,
  oldVal,
}): Record<string, any> => {
  // ... 之前的代码

  // 遍历最新的对象数据
  Object.keys(newVal).forEach((key: string) => {
    // 当前已经处理过的对象 key 记录一下
    checkedKeys.add(key);

    // 先去查看类型，判断相同类型后再使用 JSON.stringify 获取字符串结果进行比对
    if (
      typeof newVal[key] !== typeof oldVal[key] ||
      JSON.stringify(newVal[key]) !== JSON.stringify(oldVal[key])
    ) {
      diffResult[key] = newVal[key];
    }
  });
  // ...
};
```

这时候 simpleObjDiff 函数又变得更加强大，如下所示：

```ts
const result = simpleObjDiff({
  newVal: {
    a: 1,
    b: 1,
    d: [1, 2, 3],
  },
  oldVal: {
    a: 2,
    c: 2,
    d: [1, 2, 3],
  },
});
// => 返回结果为
result = {
  a: 1,
  b: 1,
  c: null,
};
```

#### 添加自定义对象属性比对

如果只使用 JSON.stringify 话，函数就没有办法灵活的处理用户的各色需求，所以开始添加自定义 diff 函数。

```ts
const simpleObjDiff = ({
  newVal,
  oldVal,
  options,
}): Record<string, any> => {
  // ... 之前的代码

  // 获取用户定义的 diff 函数
  const { diffFun } = { ...DEFAULT_OPTIONS, ...options };

  // 判断当前传入数据是否是函数
  const hasDiffFun = typeof diffFun === "function";

  // 遍历最新的对象数据
  Object.keys(newVal).forEach((key: string) => {
    // 当前已经处理过的对象 key 记录一下
    checkedKeys.add(key);

    let isChanged = false;

    if (hasDiffFun) {
      // 把当前属性 key 和对应的值传入，就可以获取结果
      const diffResultByKey = diffFun({
        key,
        newPropVal: newVal[key],
        oldPropVal: oldVal[key],
      });

      // 返回了结果则写入 diffResult，没有结果认为传入的函数不处理
      if (
        diffResultByKey !== null &&
        diffResultByKey !== undefined
      ) {
        diffResult[key] = diffResultByKey;
        isChanged = true;
      }
    }

    if (isChanged) {
      return;
    }

    if (
      typeof newVal[key] !== typeof oldVal[key] ||
      JSON.stringify(newVal[key]) !== JSON.stringify(oldVal[key])
    ) {
      diffResult[key] = needCopy
        ? JSON.parse(JSON.stringify(newVal))
        : newVal[key];
    }
  });
  // ...
};
```

此时我们尝试传入 diffFun 来看看效果：

```ts
const result = simpleObjDiff({
  newVal: {
    a: [12, 3, 4],
    b: 11,
  },
  oldVal: {
    a: [1, 2, 3],
    c: 22,
  },
  options: {
    diffFun: ({
      key,
      newPropVal,
      oldPropVal,
    }) => {
      switch (key) {
        // 处理对象中的属性 a
        case "a":
          return newPropVal.filter((item: any) => oldPropVal.includes(item));
      }
      // 其他我们选择不处理，使用默认的 JSON.stringify
      return null;
    },
  },
});
// =>
result = {
  // 结果如下所示
  a: [3],
  b: 11,
  c: null,
};
```

通过 diffFun 函数，开发者不但可以自定义属性处理，还可以利用
[fast-json-stringify](https://github.com/fastify/fast-json-stringify)
来优化内部属性处理。通过 JSON schema 预先告知对象属性类型，fast-json-stringify 性能非常高。

```ts
import fastJson from "fast-json-stringify";

const stringify = fastJson({
  title: "User Schema",
  type: "object",
  properties: {
    firstName: {
      type: "string",
    },
    lastName: {
      type: "string",
    },
    age: {
      description: "Age in years",
      type: "integer",
    },
  },
});

console.log(stringify({
  firstName: "Matteo",
  lastName: "Collina",
  age: 32,
}));
// "{\"firstName\":\"Matteo\",\"lastName\":\"Collina\",\"age\":32}"

console.log(stringify({
  lastName: "Collina",
  age: 32,
  firstName: "Matteo",
}));
// "{\"firstName\":\"Matteo\",\"lastName\":\"Collina\",\"age\":32}"
```

可以看到，利用 fast-json-stringify 无需考虑对象属性的内部顺序。

#### 添加其他处理

```ts
// 添加异常错误抛出
const invariant = (condition: boolean, errorMsg: string) => {
  if (condition) {
    throw new Error(errorMsg);
  }
};

// 判断是否是真实的对象
const isRealObject = (val: any): val is Record<string, any> => {
  return Object.prototype.toString.call(val) === "[object Object]";
};

simpleObjDiff = ({
  newVal,
  oldVal,
  options,
}: SimpleObjDiffParams): Record<string, any> => {
  // 添加错误传参处理
  invariant(!isRealObject(newVal), "params newVal must be a Object");
  invariant(!isRealObject(oldVal), "params oldVal must be a Object");

  // ...
  const { diffFun, empty } = { ...DEFAULT_OPTIONS, ...options };

  // ...

  Object.keys(oldVal).forEach((key) => {
    // 如果已经检查过了，直接返回
    if (checkedKeys.has(key)) {
      return;
    }
    // 设定空数据，建议使用 null 或 空字符串
    diffResult[key] = empty;
  });
};
```

如此一来，简单对象比对函数就基本完成了。

### 简单数组对比

有很多情况下，业务都需要进行数组类型的更新，一种方式是前端将所有的数据都传递到服务端，由服务端进行比对和更新，另一种方式则是前端设定好增删改的数据。从性能和网络传输上来看，第二种无疑是更好的方式，我们先对新旧数组做一个基本的比对处理。

```ts
const simpleListDiff = ({
  newVal,
  oldVal,
  options,
}: SimpleObjDiffParams) => {
  const opts = { ...DEFAULT_OPTIONS, ...options };

  // 获取当前的主键 key 数值，不传递 key 默认为 'id'
  const { key, getChangedItem } = opts;

  // 设定增删改行数
  const addLines = [];
  const deletedLines = [];
  const modifiedLines = [];

  // 添加检测过的数组主键，ListKey 是数字或者字符串类型
  const checkedKeys: Set<ListKey> = new Set<ListKey>();

  // 开始进行传入数组遍历
  newVal.forEach((newLine) => {
    // 根据主键去寻找之前的数据，也有可能新数据没有 key，这时候也是找不到的
    let oldLine: any = oldVal.find((x) => x[key] === newLine[key]);
    // 发现之前没有，走添加数据
    if (!oldLine) {
      addLines.push(newLine);
    } else {
      // 更新的数据 id 添加到 checkedKeys 里面去
      checkedKeys.add(oldLine[key]);

      // 传入函数 getChangedItem 来获取结果
      const result = getChangedItem!({
        newLine,
        oldLine,
      });

      // 没有结果则认为当前数据没有改过,无需处理
      if (result !== null && result !== undefined) {
        modifiedLines.push(result);
      }
    }
  });

  oldVal.forEach((oldLine) => {
    // 之前更新过不用处理
    if (checkedKeys.has(oldLine[key])) {
      return;
    }
    // 剩下的都是删除的数据
    deletedLines.push({
      [key]: oldLine[key],
    });
  });

  return {
    addLines,
    deletedLines,
    modifiedLines,
  };
};
```

此时我们就可以使用该函数进行一系列简单数据操作了。

```ts
const result = simpleListDiff({
  newVal: [
    {
      id: 1,
      cc: "bbc",
    },
    {
      bb: "123",
    },
  ],
  oldVal: [{
    id: 1,
    cc: "bb",
  }, {
    id: 2,
    cc: "bdf",
  }],
  options: {
    // 传入函数
    getChangedItem: ({
      newLine,
      oldLine,
    }) => {
      // 利用对象比对 simpleObjDiff 来处理
      const result = simpleObjDiff({
        newVal: newLine,
        oldVal: oldLine,
      });
      // 发现没有改动，返回 null
      if (!Object.keys(result).length) {
        return null;
      }
      // 否则返回对象比对过的数据
      return { id: newLine.id, ...result };
    },
    key: "id",
  },
});
// => 返回结果为
result = {
  addedLines: [{
    bb: "123",
  }],
  deletedLines: [{
    id: 2,
  }],
  modifiedLines: [{
    id: 1,
    cc: "bbc",
  }],
};
```

如此一来，我们直接可以把参数发给服务端。

#### 添加默认对比函数

这里就不传递 getChangedItem 的逻辑，函数将做如下处理。如此我们就可以不传递 getChangedItem 函数了。

```ts
const simpleListDiff = ({
  newVal,
  oldVal,
  options,
}: SimpleObjDiffParams) => {
  const opts = { ...DEFAULT_OPTIONS, ...options };

  // 获取当前的主键 key 数值，不传递 key 默认为 'id'
  const { key } = opts;

  let { getChangedItem } = opts;

  // 如果没有传递 getChangedItem，就使用 simpleObjDiff 处理
  if (!getChangedItem) {
    getChangedItem = ({
      newLine,
      oldLine,
    }) => {
      const result = simpleObjDiff({
        newVal: newLine,
        oldVal: oldLine,
      });
      if (!Object.keys(result).length) {
        return null;
      }
      return { [key]: newLine[key], ...result };
    };
  }

  //...
};
```

#### 添加排序功能

针对大部分服务端数据提交，我们只需要添加、更新和删除，我们也要考虑在编辑时候更新顺序的情况。这时候我们需要追加序号值。

```ts
const simpleListDiff = ({
  newVal,
  oldVal,
  options,
}: SimpleObjDiffParams) => {
  const opts = { ...DEFAULT_OPTIONS, ...options };

  const { key, fields, isSplit, sortName = "" } = opts;

  // 是否有 sortName 这个配置项，有我们就添加顺序
  const hasSortName: boolean = typeof sortName === "string" &&
    sortName.length > 0;

  let { getChangedItem } = opts;

  if (!getChangedItem) {
    //
  }

  // 设定增删改数
  const addLines = [];
  const deletedLines = [];
  const modifiedLines = [];
  const noChangeLines = [];

  const checkedKeys: Set<ListKey> = new Set<ListKey>();

  // 提供是否排序修改，方便用户使用
  let sortChanged = false;

  newVal.forEach((newLine, index: number) => {
    // 这时候需要查询老数组的顺序，而不是直接查询
    let oldLineIndex: any = oldVal.findIndex((x) => x[key] === newLine[key]);

    // 同样，查不到只能添加
    if (oldLineIndex === -1) {
      addLines.push({
        ...newLine,
        rowState: DataRowStates.Added,
        ...hasSortName && { [sortName]: index + 1 },
      });
      // 添加了，排序必然修改了
      sortChanged = true;
    } else {
      // 通过索引来获取之前的数据
      const oldLine = oldVal[oldLineIndex];

      // 通过之前的索引和当前的索引来判定是否存在顺序修改
      const isIndexChanged = index !== oldLineIndex;

      // 索引不一致，顺序也必然修改
      if (isIndexChanged) {
        sortChanged = true;
      }

      // 有排序名称且顺序不一致，我们就去添加顺序参数
      const addSortParams = hasSortName && index !== oldLineIndex;

      checkedKeys.add(oldLine[key]);

      const result = getChangedItem!({
        newLine,
        oldLine,
      });
      if (result !== null && result !== undefined) {
        modifiedLines.push({
          ...result,
          ...addSortParams && { [sortName]: index + 1 },
        });
      } else {
        // 处理数据没改变但是顺序改变的情况
        if (addSortParams) {
          noChangeLines.push({
            [key!]: newLine[key!],
            rowState: DataRowStates.NoChange,
            [sortName]: index + 1,
          });
        }
      }
    }
  });

  //... 删除不变

  return {
    addLines,
    deletedLines,
    modifiedLines,
    // 返回不修改的 line 以及数组是否改变
    ...hasSortName && {
      sortChanged,
      noChangeLines,
    },
  };
};
```

此时我们就可以得到顺序改造的函数了：

```ts

```

## 参考资料

[fast-json-stringify](https://github.com/fastify/fast-json-stringify)
