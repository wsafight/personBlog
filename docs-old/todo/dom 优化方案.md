#  解析那些优化 Dom 的方案

自从前端框架提供数据驱动的解决方案，我们就从刀耕火种中解脱出来了，但是面对形形色色的需求，其中有很多是框架开发者没有预想到或者社区尚未支持的。所以这个时候我们就需要切换会原生 Dom 操作。在这一篇文章中，我想来扯一扯，关于 Dom 优化 Dom 的解决方案以及与之相配合的框架和库。

## 重绘与回流



导致大多数网站和应用程序出现性能问题的都是重绘与回流。



## 节流函数

如果

某些浏览器事件可能在连续状态下高频发出，如更改页面出现的浏览器 resize 事件，或者鼠标触发的 mousemove 事件。那么如果在这些事件触发时执行代码，就会相应的将代码块执行很多次。但是通常大量的重复执行是没有必要的，比如说大家非常熟悉的搜索引擎的联想查询功能。它是在用户进行键入的同时进行的ajax数据请求。但是键盘事件触发的频率是按照字母来计算的，不是按照汉字或者单词，如果是每键入一个字母都触发一次数据请求，就非常的低效。在这种情况下，我们就有必要降低这种操作的频率，保证一定时间内，核心代码只执行一次。这样在核心代码块比较沉重的时候，就会大大提升我们的性能了。

## 使用 css 3



无论怎么去说，

will-change: transform 做优化

不管怎么说，利用新的技术总是会有性能红利。

## 事件委托

当页面存在大量元素，且每个元素上都有一个或多个事件绑定时，可能会影响性能，每一个事件绑定都是有代价的。

一个简单的处理方式是事件委托机制。它基于 DOM 标准，每个事件都有三个阶段:

事件捕获 -> 目标到达阶段 -> 事件冒泡阶段



老版本的 Ie 不支持不过，但是实现事件委托只需要冒泡就够了。

### 代表框架 react

react 框架并不是将事件绑定在真实 dom 上，而是通过自己的事件处理器来处理，将所有的事件都绑定在document上，这样真实点击的时候，冒泡到document上，react 再通过document去dispatchEvent统一处理事件

## 批量处理 

当我们在处理



### 代表框架 fastDom react





## 虚拟 dom



## 增量 dom



## 利用 webwork 实现

从 javaScript 出来第一天起，他就是单线程执行的。从现在来看，无疑是正确的道路，当然，随着现代应用的复杂。多线程也逐渐进入前端开发者的视野，其中

### 代表库 workdom neo

其实说句实话，



## OffscreenCanvas

自从前端脱离了刀耕火种的操作 dom ,

