# 浅谈生命周期

## 起源

最近在看一本书——《聊聊架构》，书中第一章便是介绍生命周期(Life Cycle)。在大学初接触到软件的时候，就有项目生命周期一说，从需求分析阶段开始到维护阶段直到消亡，当时也是不以为意。虽然后面有无数次接触到对象，网页的生命周期，当然，人的生老病死也是一种生命周期。但是当时并没有去仔细思考过生命周期对开发产生的深远的意义。


后来直到临近工作，学习了 Vue，其中Vue就有其生命周期图示。

![Vue Cycle](../images/19-07-23/lifecycle.png)

正如 Vue 官网所述：随着不断学习和使用，它的参考价值会越来越高。

## 生命周期的意义

随着思考的深入，甚至觉得不仅仅是软件，各方面的架构基础都是生命周期。不仅仅是由生到死，一天的轮回是一个生命周期，虽然是日子是一天天的过，但是随着社会的发展以及经济的提升，日常生活也在发生改变。以吃饭为例子，之前如果需要吃饭，就要出去找饭店，然后点菜以及等着饭菜上桌，最后还要回到住所。这是一个完整的生命周期。如果我们去思考一下，就会发现实际上，最核心的生命周期其实就是：选择饭馆，点菜以及吃饭，这是作为吃饭的核心也是基本的生命周期。选择吃什么以及吃饭完全是自身的心理和生理需求。至于往返以及等待上菜的时间，完全是非核心生命周期(当然，是以平常吃饭为主体，谈恋爱等不在此列)。而现在，我们完全可以通过外卖平台去实现在非核心生命周期去做其他的事情。


业务的拆分，类的拆分，甚至人类的分工本质上就是让适合的对象去做适合的事情以提升效率。通过拆分之后，就可以把一个主体做的事情分为两以及多个主体来做。让所有主体能够发挥自己能力而达到最大化。随着互联网时代的到来，在购物，写作，商品购买，货物配送，资料学习以及外出旅游等方方面面的各种生命周期都发生了分工。让用户付出最少的代价得到优秀的体验。通过演变，对于主体而言，非核心生命周期变为了服务乃至职业，核心生命周期变的更加精简从而拥有更多的时间。

## 开发的角度来看

开发者都会听过，好的程序都是高内聚，低耦合，所谓内聚，其实就是在特定生命周期内的所存在行为和状态变化都积累在自身的，而不是在多个主体上。对于代码，业务，服务甚至开发者而言，权利和义务对等可以令效率和性能达到最大。之前的asp，jsp，php开发网站对于前端后端来说，有大量的协作耦合影响着开发时间，有时候出现问题，都需要定位前端还是后端问题。而现在前后分离其实就实现了高内聚低耦合。数据问题找后端，渲染有错找前端。需要两个人共同开发的时间在变少。各个端之间也可以各自寻求各自发展与突破，以实现”端到端工程师“。内聚就是主体在有限的生命周期内做自己擅长的事情。如果大量的时间都在进行协同工作，其实就是耦合。耦合必然会带来资源的浪费。代码和服务也如此。把各个服务拆分出来，哪里是瓶颈,就提升哪里。让专业的人做专业的事。

## 以生命周期来看组件增强

组件是前端进入工程化的一个标志，如果我们把组件看为主体，我们看一看如何对主体进行功能性的增强。

### mixins方案

该方案已经被react去除，但是在vue以及微信小程序的Component仍在使用。基本代码代码如下
```
var mixin = {
  created: function () { console.log(1) }
}
var vm = new Vue({
  created: function () { console.log(2) },
  mixins: [mixin]
})
// => 1
// => 2
```
单从生命周期来看,Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。而数据与方法在内部会进行递归合并，并在发生冲突时以主体数据优先。

mixins方案很难使用的非常好，在纯正的非业务代码中(例如窗体变化，插件使用)可以使用的不错，但是当拆分主体功能获取数据时，遇到数据依赖就会写出异常丑陋的代码。该方案一方面的确解决了代码的复用性问题，另一方面却让代码难以修改，也许就因为在现实世界中很难找到于此相同的设计——依赖于主体才能够生存，且拥有各自的生命与能力。如果你看过电影毒液，那么你就清楚的了解到毒液与宿主之间是多么难以平衡，如果是多个毒液在一个宿主中则更加复杂。

所以，每次在使用mixins之前都要问一下自己，是否真的需要它，对于业务代码而言。不要在mixin中使用生命周期的钩子是一个非常不错的建议。

### propRender
从

### HOC

### hook

### fuction Api

