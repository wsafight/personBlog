在开发项目的过程中，开发者对于 setTimeout 的使用非常普遍。乍一看，一些复杂问题似乎解决了。但实际上，如果你不清楚问题为什么能解决。那么 bug 仍旧会出现。

## 深入事件循环

了解 JavaScript 引擎如何处理异步代码是非常重要的。它是创建高效 web 网站的基础。



事件循环至少有两个事件队列(实际实现会有更多，但市面上 JavaScript 执行环境非常多)：宏任务队列和微任务队列。

宏任务可以满足我们大部分的日常需求，不过如果有对时间精度要求较高的需求，宏任务就难以胜任了。
微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。

微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。

- 一次只能处理一个任务
- 一个任务在执行时候也不会被另一个任务中断

我们可以看到的细节
- 两类任务队列都是独立于时间循环之外，意味着任务的检查添加行为也在时间循环之外。同时也表明了 JavaScript 引擎一定不是单线程的。
- 所有微任务都会在下次渲染之前执行完成

事件循环任务代表浏览器执行的行为。任务分为 2 类
- 宏任务 独立的浏览器操作，渲染事件（如解析 DOM、计算布局、绘制）；用户交互事件（如鼠标点击、滚动页面、放大缩小等）；JavaScript 脚本执行事件；网络请求完成、文件读写完成事件
- 微任务 尽快执行的任务，Promise 回调，DOM 突变


## 定时器

### 延迟执行和间隔执行

### 问题

存在嵌套带调用时候，系统会设置最短时间间隔为4 ms。

还有一个很容易被忽略的地方，那就是未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1 秒，目的是为了优化后台页面的加载损耗以及降低耗电量。

Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。

## 回调精准执行的问题

### 增量时间

### 如何定时执行任务

从上文分析中，我们可以看到，无论是走微任务还是宏任务，都没有办法保证回调精准执行。
