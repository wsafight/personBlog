# 简单而复杂的定时器

在开发项目的过程中，开发者对于 setTimeout 的使用非常普遍。乍一看，一些复杂问题似乎解决了。但实际上，如果你不清楚问题为什么能解决。那么 bug 仍旧会出现。

## 深入事件循环

了解 JavaScript 引擎如何处理异步代码是非常重要的。它是创建高效 web 网站的基础。

### 为什么任务要划分为宏任务和微任务

DOM 变化非常频繁，有些需求需要监视 dom 并作出响应。早期会使用 setTimeout 轮询检查。

后来Mutation Event 采用了观察者的设计模式，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。
如果动态创建 50 个节点，就会产生 50 次回调。大大影响任务的执行效率。

简单的处理：批处理，记录多次修改。最终一次调用。setTimeout

复杂的处理：在宏任务中添加一个队列，来保证执行。

- 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。
- 微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。
- 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。

事件循环至少有两个事件队列(实际实现会有更多，延时队列等，但市面上 JavaScript 执行环境非常多)：宏任务队列和微任务队列。

宏任务可以满足我们大部分的日常需求，不过如果有对时间精度要求较高的需求，宏任务就难以胜任了。
微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。

微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。

- 一次只能处理一个任务
- 一个任务在执行时候也不会被另一个任务中断

我们可以看到的细节
- 两类任务队列都是独立于事件循环之外，意味着任务的检查添加行为也在时间循环之外。同时也表明了 JavaScript 引擎一定不是单线程的。
- 所有微任务都会在下次渲染之前执行完成

事件循环任务代表浏览器执行的行为。任务分为 2 类
- 宏任务 独立的浏览器操作，渲染事件（如解析 DOM、计算布局、绘制）；用户交互事件（如鼠标点击、滚动页面、放大缩小等）；JavaScript 脚本执行事件；网络请求完成、文件读写完成事件
- 微任务 尽快执行的任务，Promise 回调，DOM 突变

## 定时器

### setTimeout 如何实现
一种是推模型，一种是拉模型.

当通过 JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数 showName、当前发起时间、延迟执行时间，

```ts

```

### 延迟执行和间隔执行



### 问题

存在嵌套带调用时候，系统会设置最短时间间隔为4 ms。

还有一个很容易被忽略的地方，那就是未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1 秒，目的是为了优化后台页面的加载损耗以及降低耗电量。

Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。

## 回调精准执行的问题

从上文分析中，我们可以看到，无论是走微任务还是宏任务，都没有办法保证回调精准执行。

### 增量时间

我们慢慢开始使用 raf 来替代定时器。但 raf 使用屏幕刷新率则更加复杂，在不同的显示器上，回调执行频率差距太大。

为了解决这样的问题，需要引入时间增量的概念：从上一帧起流逝的时间。

代码不能简单的依靠每一帧移动的像素，而使用每秒移动的像素:

```ts
enemy.pos.x += 5;

// =>

enemy.pos.x += 150 * (currentTime - lastTime);
lastTime = currentTime;
```

如果一个对象在游戏中的状态改变需要一定的时间，那么则应该使用增量时间。这样才能保证在未来的场景下还可以正常的工作。

当然，增量时间虽然能保证在不同的帧率中执行，但是还是会有其他问题，与物理相关的游戏在不同帧率的表现上会有差异（数值积分）。
这个问题最简单的解法就是限制帧率（又回到 setTimeout）。

### 如何定时执行任务



