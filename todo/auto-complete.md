# 代码自动补全原理

你知道编辑器是如何为你的代码做出自动补全与提示的吗 ？这是一个复杂的问题，事实上，不同的自动补全工具所使用技术不一定相同，但它们却存在基本相似的原理。

当我们将一个项目导入编辑器时，编辑器的一个编译器前端分析程序将分析你的代码，然后你的代码会被构建成一颗抽象语法树 (AST)。在这一步骤中，编辑器所作的事情与编译器是类似的，它们分析然后读懂代码。之后，文本索引将依据抽象语法树被建立，这样编辑器就会知道如何为你提供自动完成补全功能。这种索引是按照命名空间切分的，例如每个模块，每个结构体和每个函数都会有它们自己的索引。这样，如果编辑器检测到你正在输入函数或者变量名，那它就可以根据索引实时提供完整的名称的补全。

现在，对于这个功能来说，最重要的是实现时间和内存方面的高性能。如果我们仅仅只是用一个列表平铺的存储每个名字将是非常低效的。为了获得较高的性能，索引会使用一个有趣的数据结构，这个数据结构的名称是前缀树(Trie)。我相信你平时会经常性的使用浏览器，那么你也许会注意到浏览器的地址栏中也是有自动补全功能，例如当你输入 https://goo 时，https://google 就将 立即出现在地址栏下方的候选词中，览器这时所使用的技术其实与编辑器的自动补全机制的技术是一样的，它们都是前缀树。

## 前缀树

前缀树又称为字典树，是一种有序树，用于保存关联数据。其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。如 下是保存了字符串 “a”，“b”，“at”，“atm”，“ao” 的前缀树。通常来说，在实现前缀树的时候，会在节点加入一个字段来表明其是否是一 个完整单词。当从键盘键入 “a” 时，就可以通过遍历 “a” 子节点的内容列出 “atm” 与 “ao” 这两个候选词啦。

## LSP

rust-analyzer 是 Rust 的 LSP(语言服务协议) 实现，它为许多代码编辑器(包括 vscode，emacs 和 vim)提供了自动补全，代码提示，跳转 等特性。LSP 是一种开放的基于 JSON-RPC 的协议，用于桥接源代码编辑器或集成开发环境(IDE)与提供编程语言特定功能的服 务。LSP 最初是为 Microsoft Visual Studio 开发的，但现在已经成为一个开放标准。在 2016 年 6 月 27 日，微软宣布与 Red Hat 和 Codenvy 合作，对该协议规范进行标准化。

现代的编辑器为开发人员提供了许多复杂的特性,例如代码补全，重构，跳转，语法高亮显示以及错误和警告标记等。举个例子，一个程序员已经编写好了许多代码，他想对代码做一次重构，现在他希望将方法 creat 重命名为 create。他可以手动编辑相应的 源代码文件并将所有出现的旧方法名称更改为新名称，或者是使用编辑器的重构功能自动进行所有必要的更改。为了支持这种快 速重构,编辑器需要对编写程序源代码所用的编程语言有深入的了解，包括这个编程语言的所有语法。如果你的编辑器只是执行 了简单的搜索和替换则可能会引入错误。

你发现我上面举的例子中一个程序员希望将方法 creat 重命名为 create。这可不是虚构的，现实中的许多程序员都非常期待这件事! 在许多年前，当时的链接器只支持 5 个字符的函数名，因此在 *nix 系统中，create 这个单词总是被使用 creat 替代。就如你在 Linux manual page (https://man7.org/linux/man-pages/man2/creat.2.html) 中看到的那样，这个历史遗留问题直到现在还因为要保持兼容性而没法被解决。

当程序员在编辑器中编辑一个或多个源代码文件时,编辑器会使用 JSON-RPC 与 LSP 沟通。编辑器告知 LSP 用户正在做什么，例如打开文件，在特定文本位置插入字符等。编辑器还可以请求 LSP 执行一些特定的功能，例如格式化源码中的指定范围的内容。
