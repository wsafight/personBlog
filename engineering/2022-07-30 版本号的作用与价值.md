# 聊聊开发中遇到的版本问题

在项目开发和运行的过程中，总是需要各类升级。例如某个功能需要更高的依赖、数据项需要进行兼容等等问题。遇到此类问题我们需要使用版本号来解决。今天我们就来分析一下项目迭代过程中会遇到的升级问题以及如何使用版本号来解决。

通常来说升级会涉及到三个点：

- 向下兼容
- 协商升级
- 拒绝服务


## 通过版本号进行数据缓存

很多情况，我们为了减少网络请求都会使用数据缓存。如果是一个较为稳定的数据。我们可以添加版本号进行缓存（建议同时添加一个足够长的过期时间方便获取）。

以 localStorage 为例，代码如下所示：

```ts
interface Store<T> {
  /** 存储数据 */
  data: T;
  /** 
   * 当前版本数据,可以是一个数字或一个日期字符串 '220101-1' 
   * 后续的 -1 是为了当天发布多个版本而准备的。
   */
  version: string | number;
  /** 
   * 过期时间 
   * 可以使用 时间戳（天数），天数 dayjs 等
   */
  expries: string ｜ number;
}
  
/**
  * 实际存储 key 值 
  */
const XXX_STORAGE_KEY = 'storageKey';

const isNeedUpgrade = async <T>(): Promise<boolean> => {
  const storeJSONStr = localStorage.getItem(XXX_STORAGE_KEY);
  // 没有存储 JSON 字符串
  if (storeJSONStr === null) {
    return true;
  }

  let store: Partial<Store<T>> = {};

  try {
    store = JSON.parse(storeJSONStr)
  } catch (e) {
    // JSON 字符串解析失败
    return true;
  }

  const { expries, version: localVersion } = store;

  // 没有过期时间获取当前时间超过过期时间
  if (!expries || isOverTime(expries)) {
    return true;
  }

  // 没有缓存本地版本
  if (!localVersion) {
    return true;
  }

  const currentVersion = await getCurrentVersionForXXXStore();

  // 版本不一致
  if (currentVersion !== localVersion) {
    return true;
  }

  // 无需升级
  return false;
}
```

当前代码其实就涉及到了上述所说的 协商升级。

## 使用版本号进行 api 维护

随着业务的发展，数据结构不可避免会发生一定的改变，如果仅仅只是增加一个数据，开发者可以直接在服务端做一下向下兼容即可。但有些时候我们可能需要做出一系列的调整，诸如前一个版本处理传递上来的 A 和 C 数据，但是后一个版本仅处理 A 数据即可，这时候我们可能就无法通过数据传输来确定如何调用。因为我们无法保证服务端与客户端能够同步升级。此时我们不得不借助版本号。

```ts
/**
 * 2019-11-12 版本 15 兼容处理了 xxxx, xxxx
 * 2018-12-10 版本 14 xxxxxx
 */
const api = initRequest({
  // 全局 api 版本号
  apiVersion: 15,
})

const queryXXX = () => {
  return api({
    // 可以使用 api 版本号，不传递默认使用全局版本号
    apiVersion: 3,
  })
}
```

使用或者不使用全局版本号都有各自的优点。使用全局版本号一个版本可以同时进行多处修改，方便开发者维护。但是如果 api 兼容过多的话，apiVersion 也会升级的很快。最终反而不利于维护。大家可以酌情处理，如果是互联网项目，大家可以考虑使用 api 独立版本号，如果是企业服务则优先使用全局版本号。

全局版本号还有一个利好就是可以控制 api 升级的时机，如果我们把全局版本号放在服务端进行控制，我们就可以先进行前端升级然后进行后端拒绝服务。这样的话就不需要在服务端维护多个版本。代码如下所示：

```ts
export const handleVersionError(err) {
  // 版本不支持和
  if (err.errCode !== 'versionNotSupport') {
    return;
  }

  this.$confirm('当前版本过低，无法正常使用此功能。', '温馨提示', {
    confirmButtonText: '刷新页面应用新版本',
    cancelButtonText: '取消',
    type: 'warning'
  }).then(() => {
    location.reload();
  })
}
```

当然了，我们大可不必如此激进的拒绝服务。但是很多情况下我们线上有多个版本时候。我们可以设定最低使用版本，然后确保用户能够平滑升级（有些用户可能出现几个星期都不刷新界面的情况）。我们可以在 api 稳定后提供 versionNotSupport 使得用户不再使用或者提供过期数据。

如果你使用小程序开发，也可以通过 updateManager 重启升级。也是

```ts
const updateManager = Taro.getUpdateManager()

updateManager.onCheckForUpdate(function (res) {
  // 请求完新版本信息的回调
  console.log(res.hasUpdate)
})

updateManager.onUpdateReady(function () {
  Taro.showModal({
    title: '更新提示',
    content: '新版本已经准备好，是否重启应用？',
    success: function (res) {
      if (res.confirm) {
        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启
        updateManager.applyUpdate()
      }
    }
  })
})
updateManager.onUpdateFailed(function () {
  // 新的版本下载失败
})
```


## 乐观锁

乐观是
## 其他

对于前端开发者来说，我们

如果想进一步了解缓存，这里我推荐一下我之前的。

[前端 api 请求缓存方案](https://segmentfault.com/a/1190000018940422)

[手写一个基于 Proxy 的缓存库](https://segmentfault.com/a/1190000039217566)


我们可以去学习一下 server